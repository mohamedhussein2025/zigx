const std = @import("std");
const fs = std.fs;
const config = @import("config");

/// Generates the _native.py loader file
pub fn generateNativePy(
    allocator: std.mem.Allocator,
    project_dir: []const u8,
    cfg: *const config.ZigxConfig,
) !void {
    const path = try std.fs.path.join(allocator, &.{ project_dir, cfg.name, "_native.py" });
    defer allocator.free(path);

    const file = try fs.cwd().createFile(path, .{});
    defer file.close();

    // Build the file content in memory
    var content: std.ArrayListUnmanaged(u8) = .empty;
    defer content.deinit(allocator);

    // Write header
    try appendFmt(&content, allocator,
        \\"""
        \\Native extension loader for {s}
        \\
        \\This file is auto-generated by ZigX. Do not edit manually.
        \\"""
        \\
        \\import ctypes
        \\import os
        \\import sys
        \\import sysconfig
        \\from pathlib import Path
        \\from typing import Optional
        \\
        \\# Extension suffix for the current platform
        \\_EXT_SUFFIX = sysconfig.get_config_var("EXT_SUFFIX") or ".so"
        \\
        \\def _find_library() -> Optional[Path]:
        \\    """Find the native library in various locations."""
        \\    module_dir = Path(__file__).parent
        \\    lib_name = f"_{s}_ext" + _EXT_SUFFIX
        \\    
        \\    # Possible locations
        \\    search_paths = [
        \\        module_dir / lib_name,
        \\        module_dir.parent / ".zigx_build" / lib_name,
        \\        module_dir.parent / "target" / "debug" / lib_name,
        \\        module_dir.parent / "target" / "release" / lib_name,
        \\    ]
        \\    
        \\    for path in search_paths:
        \\        if path.exists():
        \\            return path
        \\    
        \\    return None
        \\
        \\def _load_library():
        \\    """Load the native library."""
        \\    lib_path = _find_library()
        \\    if lib_path is None:
        \\        raise ImportError(
        \\            f"Could not find native library. "
        \\            f"Run 'zigx develop' or 'zigx build' first."
        \\        )
        \\    
        \\    return ctypes.CDLL(str(lib_path))
        \\
        \\# Load the library
        \\_lib = _load_library()
        \\
        \\
    , .{ cfg.name, cfg.name });

    // Generate function signatures and wrappers
    for (cfg.functions) |func| {
        try generateFunctionBinding(&content, allocator, func);
    }

    // Write to file
    try file.writeAll(content.items);
}

fn generateFunctionBinding(content: *std.ArrayListUnmanaged(u8), allocator: std.mem.Allocator, func: config.ZigxConfig.FunctionConfig) !void {
    // Generate argtypes
    try appendFmt(content, allocator, "# Function: {s}\n", .{func.name});
    try appendFmt(content, allocator, "_lib.{s}.argtypes = [", .{func.name});

    var first = true;
    for (func.args) |arg| {
        if (!first) try content.appendSlice(allocator, ", ");
        first = false;
        try content.appendSlice(allocator, zigTypeToCtype(arg.zig_type));
    }
    try content.appendSlice(allocator, "]\n");

    // Generate restype
    try appendFmt(content, allocator, "_lib.{s}.restype = {s}\n\n", .{ func.name, zigTypeToCtype(func.return_type) });

    // Generate wrapper function
    try appendFmt(content, allocator, "def {s}(", .{func.name});

    first = true;
    for (func.args) |arg| {
        if (!first) try content.appendSlice(allocator, ", ");
        first = false;
        try appendFmt(content, allocator, "{s}: {s}", .{ arg.name, arg.py_type });
    }
    try appendFmt(content, allocator, ") -> {s}:\n", .{zigTypeToPythonType(func.return_type)});

    // Docstring
    if (func.doc.len > 0) {
        try appendFmt(content, allocator, "    \"\"\"{s}\"\"\"\n", .{func.doc});
    }

    // Function body
    if (std.mem.eql(u8, func.return_type, "void")) {
        try appendFmt(content, allocator, "    _lib.{s}(", .{func.name});
    } else {
        try appendFmt(content, allocator, "    return _lib.{s}(", .{func.name});
    }

    first = true;
    for (func.args) |arg| {
        if (!first) try content.appendSlice(allocator, ", ");
        first = false;
        try appendFmt(content, allocator, "{s}", .{arg.name});
    }
    try content.appendSlice(allocator, ")\n\n");
}

fn appendFmt(list: *std.ArrayListUnmanaged(u8), allocator: std.mem.Allocator, comptime fmt: []const u8, args: anytype) !void {
    const str = try std.fmt.allocPrint(allocator, fmt, args);
    defer allocator.free(str);
    try list.appendSlice(allocator, str);
}

fn zigTypeToCtype(zig_type: []const u8) []const u8 {
    if (std.mem.eql(u8, zig_type, "i8")) return "ctypes.c_int8";
    if (std.mem.eql(u8, zig_type, "i16")) return "ctypes.c_int16";
    if (std.mem.eql(u8, zig_type, "i32")) return "ctypes.c_int32";
    if (std.mem.eql(u8, zig_type, "i64")) return "ctypes.c_int64";
    if (std.mem.eql(u8, zig_type, "u8")) return "ctypes.c_uint8";
    if (std.mem.eql(u8, zig_type, "u16")) return "ctypes.c_uint16";
    if (std.mem.eql(u8, zig_type, "u32")) return "ctypes.c_uint32";
    if (std.mem.eql(u8, zig_type, "u64")) return "ctypes.c_uint64";
    if (std.mem.eql(u8, zig_type, "f32")) return "ctypes.c_float";
    if (std.mem.eql(u8, zig_type, "f64")) return "ctypes.c_double";
    if (std.mem.eql(u8, zig_type, "bool")) return "ctypes.c_bool";
    if (std.mem.eql(u8, zig_type, "void")) return "None";
    if (std.mem.eql(u8, zig_type, "usize")) return "ctypes.c_size_t";
    if (std.mem.eql(u8, zig_type, "isize")) return "ctypes.c_ssize_t";
    return "ctypes.c_void_p";
}

fn zigTypeToPythonType(zig_type: []const u8) []const u8 {
    if (std.mem.eql(u8, zig_type, "void")) return "None";
    if (std.mem.startsWith(u8, zig_type, "i") or std.mem.startsWith(u8, zig_type, "u")) return "int";
    if (std.mem.startsWith(u8, zig_type, "f")) return "float";
    if (std.mem.eql(u8, zig_type, "bool")) return "bool";
    return "int";
}

/// Generates .pyi type stub file
pub fn generatePyi(
    allocator: std.mem.Allocator,
    project_dir: []const u8,
    cfg: *const config.ZigxConfig,
) !void {
    const filename = try std.fmt.allocPrint(allocator, "_{s}.pyi", .{cfg.name});
    defer allocator.free(filename);

    const path = try std.fs.path.join(allocator, &.{ project_dir, cfg.name, filename });
    defer allocator.free(path);

    const file = try fs.cwd().createFile(path, .{});
    defer file.close();

    var content: std.ArrayListUnmanaged(u8) = .empty;
    defer content.deinit(allocator);

    // Write header
    try appendFmt(&content, allocator,
        \\"""
        \\Type stubs for {s} native extension
        \\
        \\This file is auto-generated by ZigX. Do not edit manually.
        \\"""
        \\
        \\
    , .{cfg.name});

    // Generate stubs for each function
    for (cfg.functions) |func| {
        try appendFmt(&content, allocator, "def {s}(", .{func.name});

        var first = true;
        for (func.args) |arg| {
            if (!first) try content.appendSlice(allocator, ", ");
            first = false;
            try appendFmt(&content, allocator, "{s}: {s}", .{ arg.name, arg.py_type });
        }
        try appendFmt(&content, allocator, ") -> {s}:\n", .{zigTypeToPythonType(func.return_type)});

        if (func.doc.len > 0) {
            try appendFmt(&content, allocator, "    \"\"\"{s}\"\"\"\n", .{func.doc});
        }
        try content.appendSlice(allocator, "    ...\n\n");
    }

    try file.writeAll(content.items);
}

/// Generates __init__.py
pub fn generateInitPy(
    allocator: std.mem.Allocator,
    project_dir: []const u8,
    cfg: *const config.ZigxConfig,
) !void {
    const path = try std.fs.path.join(allocator, &.{ project_dir, cfg.name, "__init__.py" });
    defer allocator.free(path);

    const file = try fs.cwd().createFile(path, .{});
    defer file.close();

    var content: std.ArrayListUnmanaged(u8) = .empty;
    defer content.deinit(allocator);

    try appendFmt(&content, allocator,
        \\"""
        \\{s} - A Python extension built with ZigX
        \\"""
        \\
        \\from ._native import (
        \\
    , .{cfg.name});

    for (cfg.functions) |func| {
        try appendFmt(&content, allocator, "    {s},\n", .{func.name});
    }

    try appendFmt(&content, allocator,
        \\)
        \\
        \\__version__ = "{s}"
        \\__all__ = [
        \\
    , .{cfg.version});

    for (cfg.functions) |func| {
        try appendFmt(&content, allocator, "    \"{s}\",\n", .{func.name});
    }

    try content.appendSlice(allocator, "]\n");
    try file.writeAll(content.items);
}
